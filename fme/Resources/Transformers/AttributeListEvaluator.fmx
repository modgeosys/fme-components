#! <?xml version="1.0" encoding="UTF-8" ?>
#! <TRANSFORMER
# TRANSFORMER_BEGIN AttributeListEvaluator,1,Attributes,6ee558fa-12a0-43d0-b615-37cf50b46b57,"Linked by Default",No,NO_PARALLELISM,,No,18592,YES,No,36
# <p>Evaluates a standard comma-delimited list of attribute names (as you get from a standard Attribute List parameter), adding name and value sublists.</p>
# <p>For issues or questions, please Create an issue <a href="https://github.com/modgeosys/fme-components/issues_">here</a>.  For the source, including test driver components, please see the <a href="https://github.com/modgeosys/fme-components_">Github repository</a>.</p>
# <p>Copyright &copy; 2017-2019 by Modern geoSystems, released under <a href="https://github.com/modgeosys/fme-components/raw/master/LICENSE">this BSD 3-clause license</a>.</p>
# TRANSFORMER_END
#!   ATTR_TYPE_ENCODING="SDF"
#!   BLOCKED_LOOPING="No"
#!   CATEGORY="Attributes"
#!   DESCRIPTION="&lt;p&gt;Evaluates a standard comma-delimited list of attribute names (as you get from a standard Attribute List parameter), adding name and value sublists.&lt;/p&gt;&#10;&lt;p&gt;For issues or questions, please Create an issue &lt;a href=&quot;https://github.com/modgeosys/fme-components/issues_&quot;&gt;here&lt;/a&gt;.  For the source, including test driver components, please see the &lt;a href=&quot;https://github.com/modgeosys/fme-components_&quot;&gt;Github repository&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Copyright &amp;copy; 2017-2019 by Modern geoSystems, released under &lt;a href=&quot;https://github.com/modgeosys/fme-components/raw/master/LICENSE&quot;&gt;this BSD 3-clause license&lt;/a&gt;.&lt;/p&gt;"
#!   DOC_EXTENTS="4500 1e-5"
#!   DOC_TOP_LEFT="-600 -150"
#!   EXPLICIT_BOOKMARK_ORDER="false"
#!   FME_BUILD_NUM="18592"
#!   FME_DOCUMENT_GUID="6ee558fa-12a0-43d0-b615-37cf50b46b57"
#!   FME_DOCUMENT_PRIORGUID="f12591b2-126a-4648-8ad4-92fd55c02cc4"
#!   FME_LINKED_TRANSFORMER_VERSION="1"
#!   FME_PROCESS_COUNT="NO_PARALLELISM"
#!   FME_PROCESS_GROUPS_ORDERED="No"
#!   FME_PROCESS_GROUP_BY=""
#!   FME_SERVER_SERVICES=""
#!   FMX_ATTRIBUTE_PROPOGATION_MODE="AUTO"
#!   FMX_INSERT_MODE="Linked by Default"
#!   HISTORY="2019-07-25,Kevin&lt;space&gt;Weller,Initial&lt;space&gt;publication."
#!   ITERATION_COUNT_ATTR=""
#!   LAST_SAVE_BUILD="FME(R) 2018.1.2.1 (20190319 - Build 18592 - linux-x64)"
#!   LAST_SAVE_DATE="2019-07-25T15:51:45"
#!   MARKDOWN_DESCRIPTION="Evaluates a standard comma-delimited list of attribute names (as you get from a standard Attribute List parameter), adding name and value sublists.&#10;&#10;For issues or questions, please Create an issue [here](https://github.com/modgeosys/fme-components/issues_).  For the source, including test driver components, please see the [Github repository](https://github.com/modgeosys/fme-components_).&#10;&#10;Copyright &amp;copy; 2017-2019 by Modern geoSystems, released under [this BSD 3-clause license](https://github.com/modgeosys/fme-components/raw/master/LICENSE)."
#!   MARKDOWN_USAGE="### Ports&#10;&#10;#### Input&#10;Feed the features containing the attribute list to be evaluated.&#10;&#10;#### Output&#10;The features emerge here with the named list evaluated.&#10;&#10;### Parameters&#10;&#10;#### Attribute_Names&#10;A comma-delimited list of attribute names to be evaluated.&#10;&#10;#### Evaluated_Attribute_List_Name&#10;The name to give the resulting list.  Defaults to `_list`. &#10;"
#!   MAX_LOOP_ITERATIONS=""
#!   PASSWORD=""
#!   PYTHON_COMPATIBILITY="36"
#!   SHOW_ANNOTATIONS="true"
#!   SHOW_INFO_NODES="true"
#!   TITLE="AttributeListEvaluator"
#!   USAGE="&lt;h3&gt;Ports&lt;/h3&gt;&#10;&lt;h4&gt;Input&lt;/h4&gt;&#10;&lt;p&gt;Feed the features containing the attribute list to be evaluated.&lt;/p&gt;&#10;&lt;h4&gt;Output&lt;/h4&gt;&#10;&lt;p&gt;The features emerge here with the named list evaluated.&lt;/p&gt;&#10;&lt;h3&gt;Parameters&lt;/h3&gt;&#10;&lt;h4&gt;Attribute_Names&lt;/h4&gt;&#10;&lt;p&gt;A comma-delimited list of attribute names to be evaluated.&lt;/p&gt;&#10;&lt;h4&gt;Evaluated_Attribute_List_Name&lt;/h4&gt;&#10;&lt;p&gt;The name to give the resulting list.  Defaults to &lt;code&gt;_list&lt;/code&gt;. &lt;/p&gt;"
#!   USE_MARKDOWN="YES"
#!   VIEW_POSITION="-2538.03 87.0009"
#!   WARN_INVALID_XFORM_PARAM="Yes"
#!   WORKSPACE_VERSION="1"
#!   XFORM_DEPRECATED="No"
#!   ZOOM_SCALE="100"
#! >
#! <DATASETS>
#! </DATASETS>
#! <DATA_TYPES>
#! </DATA_TYPES>
#! <GEOM_TYPES>
#! </GEOM_TYPES>
#! <FEATURE_TYPES>
#! </FEATURE_TYPES>
#! <FMESERVER>
#! </FMESERVER>
#! <GLOBAL_PARAMETERS>
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI ATTRLIST_COMMAS_OR_ATTR Attribute_Names &quot; &quot; Attribute Names:"
#!   DEFAULT_VALUE=""
#!   IS_STAND_ALONE="true"
#! />
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL TEXT Evaluated_Attribute_List_Name Evaluated Attribute List Name:"
#!   DEFAULT_VALUE="_list"
#!   IS_STAND_ALONE="true"
#! />
#! </GLOBAL_PARAMETERS>
#! <COMMENTS>
#! </COMMENTS>
#! <CONSTANTS>
#! </CONSTANTS>
#! <BOOKMARKS>
#! </BOOKMARKS>
#! <TRANSFORMERS>
#! <TRANSFORMER
#!   IDENTIFIER="2"
#!   TYPE="PythonCaller"
#!   VERSION="4"
#!   POSITION="2400 -150"
#!   BOUNDING_RECT="2400 -150 -1 -1"
#!   ORDER="500000000000003"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18592"
#! >
#!     <OUTPUT_FEAT NAME="OUTPUT"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_attribute_names" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_attribute_name_list{}" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_attribute_name_list{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_attribute_name_list{}.value" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="ADVANCED_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="HIDE_ATTRIBUTES" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="LIST_ATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="NEW_ATTRIBUTES" PARM_VALUE="_attribute_name_list&lt;opencurly&gt;&lt;closecurly&gt;.name _attribute_name_list&lt;opencurly&gt;&lt;closecurly&gt;.value"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PYTHONSOURCE" PARM_VALUE="import&lt;space&gt;fme&lt;lf&gt;import&lt;space&gt;fmeobjects&lt;lf&gt;&lt;lf&gt;def&lt;space&gt;processFeature&lt;openparen&gt;feature&lt;closeparen&gt;:&lt;lf&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;i&lt;space&gt;=&lt;space&gt;0&lt;lf&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;for&lt;space&gt;attribute_name&lt;space&gt;in&lt;space&gt;feature.getAttribute&lt;openparen&gt;&lt;apos&gt;_attribute_name_list&lt;opencurly&gt;&lt;closecurly&gt;&lt;apos&gt;&lt;closeparen&gt;:&lt;lf&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;feature.setAttribute&lt;openparen&gt;&lt;apos&gt;_attribute_name_list&lt;opencurly&gt;&lt;apos&gt;&lt;space&gt;+&lt;space&gt;str&lt;openparen&gt;i&lt;closeparen&gt;&lt;space&gt;+&lt;space&gt;&lt;apos&gt;&lt;closecurly&gt;.name&lt;apos&gt;&lt;comma&gt;&lt;space&gt;attribute_name&lt;closeparen&gt;&lt;lf&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;feature.setAttribute&lt;openparen&gt;&lt;apos&gt;_attribute_name_list&lt;opencurly&gt;&lt;apos&gt;&lt;space&gt;+&lt;space&gt;str&lt;openparen&gt;i&lt;closeparen&gt;&lt;space&gt;+&lt;space&gt;&lt;apos&gt;&lt;closecurly&gt;.value&lt;apos&gt;&lt;comma&gt;&lt;space&gt;feature.getAttribute&lt;openparen&gt;attribute_name&lt;closeparen&gt;&lt;closeparen&gt;&lt;lf&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;feature.removeAttribute&lt;openparen&gt;&lt;apos&gt;_attribute_name_list&lt;opencurly&gt;&lt;closecurly&gt;&lt;apos&gt;&lt;closeparen&gt;&lt;lf&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;i&lt;space&gt;+=&lt;space&gt;1"/>
#!     <XFORM_PARM PARM_NAME="PYTHONSYMBOL" PARM_VALUE="processFeature"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="PythonCaller"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="7"
#!   TYPE="AttributeSplitter"
#!   VERSION="3"
#!   POSITION="900 -150"
#!   BOUNDING_RECT="900 -150 -1 -1"
#!   ORDER="500000000000004"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18592"
#! >
#!     <OUTPUT_FEAT NAME="OUTPUT"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_attribute_names" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_attribute_name_list{}" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="ATTR_NAME" PARM_VALUE="_attribute_names"/>
#!     <XFORM_PARM PARM_NAME="DELIMITER" PARM_VALUE="&lt;comma&gt;"/>
#!     <XFORM_PARM PARM_NAME="DROP_EMPTY_PARTS" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="LIST_NAME" PARM_VALUE="_attribute_name_list"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRIM_OPTION" PARM_VALUE="Both"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AttributeSplitter"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="10"
#!   TYPE="ParameterFetcher"
#!   VERSION="4"
#!   POSITION="150 -150"
#!   BOUNDING_RECT="150 -150 -1 -1"
#!   ORDER="500000000000005"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18592"
#! >
#!     <OUTPUT_FEAT NAME="OUTPUT"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_attribute_names" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="ATTR_LIST" PARM_VALUE="_attribute_names $(Attribute_Names)"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="ParameterFetcher"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="13"
#!   TYPE="ListSorter"
#!   VERSION="4"
#!   POSITION="1650 -150"
#!   BOUNDING_RECT="1650 -150 -1 -1"
#!   ORDER="500000000000006"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18592"
#! >
#!     <OUTPUT_FEAT NAME="OUTPUT"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_attribute_names" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_attribute_name_list{}" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="ORDER" PARM_VALUE="Ascending"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="SRC_LIST" PARM_VALUE="_attribute_name_list{}"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TYPE" PARM_VALUE="Alphabetic"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="ListSorter"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="16"
#!   TYPE="ListRenamer"
#!   VERSION="1"
#!   POSITION="3150 -150"
#!   BOUNDING_RECT="3150 -150 -1 -1"
#!   ORDER="500000000000007"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18592"
#! >
#!     <OUTPUT_FEAT NAME="OUTPUT"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_attribute_names" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_list{}" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_list{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_list{}.value" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="LEAVE_ORIG" PARM_VALUE="No"/>
#!     <XFORM_PARM PARM_NAME="LIST_ACTION" PARM_VALUE="Rename"/>
#!     <XFORM_PARM PARM_NAME="LIST_COMPONENT_NAMES" PARM_VALUE="_attribute_name_list&lt;opencurly&gt;&lt;closecurly&gt;,$(Evaluated_Attribute_List_Name)&lt;opencurly&gt;&lt;closecurly&gt;"/>
#!     <XFORM_PARM PARM_NAME="LIST_COMPONENT_NAMES_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="LIST_NAME" PARM_VALUE="_attribute_name_list&lt;opencurly&gt;&lt;closecurly&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="ListRenamer"/>
#! </TRANSFORMER>
#! </TRANSFORMERS>
#! <SUBDOCUMENT_IOS>
#! <SUBDOCUMENT_IO
#!   IDENTIFIER="3"
#!   NAME="Input"
#!   POSITION="-600 -150"
#!   BOUNDING_RECT="-600 -150 -1 -1"
#!   COLLAPSED="true"
#!   PUBLISHED="true"
#!   IS_SOURCE="true"
#!   ATTR_MODE="0"
#! >
#! </SUBDOCUMENT_IO>
#! <SUBDOCUMENT_IO
#!   IDENTIFIER="5"
#!   NAME="Output"
#!   POSITION="3900 -150"
#!   BOUNDING_RECT="3900 -150 -1 -1"
#!   COLLAPSED="true"
#!   IS_SOURCE="false"
#!   ATTR_MODE="0"
#! >
#! </SUBDOCUMENT_IO>
#! </SUBDOCUMENT_IOS>
#! <FEAT_LINKS>
#! <FEAT_LINK
#!   IDENTIFIER="11"
#!   SOURCE_NODE="3"
#!   TARGET_NODE="10"
#!   SOURCE_PORT_DESC="0"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="17"
#!   SOURCE_NODE="2"
#!   TARGET_NODE="16"
#!   SOURCE_PORT_DESC="fo 0 OUTPUT"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="14"
#!   SOURCE_NODE="7"
#!   TARGET_NODE="13"
#!   SOURCE_PORT_DESC="fo 0 OUTPUT"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="12"
#!   SOURCE_NODE="10"
#!   TARGET_NODE="7"
#!   SOURCE_PORT_DESC="fo 0 OUTPUT"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="15"
#!   SOURCE_NODE="13"
#!   TARGET_NODE="2"
#!   SOURCE_PORT_DESC="fo 0 OUTPUT"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="18"
#!   SOURCE_NODE="16"
#!   TARGET_NODE="5"
#!   SOURCE_PORT_DESC="fo 0 OUTPUT"
#!   TARGET_PORT_DESC="0"
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! </FEAT_LINKS>
#! <BREAKPOINTS>
#! </BREAKPOINTS>
#! <ATTR_LINKS>
#! </ATTR_LINKS>
#! <SUBDOCUMENTS>
#! </SUBDOCUMENTS>
#! <LOOKUP_TABLES>
#! </LOOKUP_TABLES>
#! </TRANSFORMER>

FME_PYTHON_VERSION 36
DEFAULT_MACRO $(AttributeListEvaluator_WORKSPACE_NAME)_Attribute_Names 
DEFAULT_MACRO $(AttributeListEvaluator_WORKSPACE_NAME)_Evaluated_Attribute_List_Name _list
#! START_HEADER
#! END_HEADER

DEFAULT_MACRO WB_CURRENT_CONTEXT
DEFAULT_MACRO AttributeListEvaluator_WORKSPACE_NAME ""
INCLUDE [puts {MACRO WB_OLD_CONTEXT_$(AttributeListEvaluator_WORKSPACE_NAME) $(WB_CURRENT_CONTEXT)};          puts {MACRO WB_CURRENT_CONTEXT $(AttributeListEvaluator_WORKSPACE_NAME)}]
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(AttributeListEvaluator_WORKSPACE_NAME)_Input1564091505 Input Splitter"   INPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_Input"   OUTPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_Input"
# -------------------------------------------------------------------------
Tcl2 proc $(AttributeListEvaluator_WORKSPACE_NAME)_ParameterFetcher_doFetch {} {    foreach {name val} {"_attribute_names {$($(AttributeListEvaluator_WORKSPACE_NAME)_Attribute_Names$encode)}"} {         if { [string match {*<at>*} $val] == 1 } {             set val [FME_Execute EvaluateExpression {STRING} $val {$(AttributeListEvaluator_WORKSPACE_NAME)_ParameterFetcher}];         } elseif {[string match {*FME_CONDITIONAL*} $val] == 1} {             set val [FME_Execute EvaluateExpression {STRING} $val {$(AttributeListEvaluator_WORKSPACE_NAME)_ParameterFetcher}];         } else {             set val [FME_DecodeTextOrAttr $val];         };       FME_SetAttribute [FME_DecodeText $name] $val    } }
FACTORY_DEF * TeeFactory    FACTORY_NAME $(AttributeListEvaluator_WORKSPACE_NAME)_ParameterFetcher    INPUT  FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_Input"    OUTPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_ParameterFetcher_OUTPUT"         @Tcl2($(AttributeListEvaluator_WORKSPACE_NAME)_ParameterFetcher_doFetch)
# -------------------------------------------------------------------------
Tcl2 set $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_c6d6701f_560d_4561_8f32_58398ec9aca31_splitDelim [FME_DecodeText {<comma>}];      if { [regexp {^([1-9][0-9]*s)+$} [set $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_c6d6701f_560d_4561_8f32_58398ec9aca31_splitDelim]] }      {         set $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_c6d6701f_560d_4561_8f32_58398ec9aca31_splitWidths [split [regsub -all {s$} {<comma>} {}] s];         proc $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_doSplit {}         {            global $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_c6d6701f_560d_4561_8f32_58398ec9aca31_splitWidths;            set source [FME_GetAttribute [FME_DecodeText {_attribute_names}]];            set attrNum 0;            set listName [FME_DecodeText {_attribute_name_list}];            set attrPos 0;            set keepEmptyParts [string equal {No} {No}];            foreach width [set $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_c6d6701f_560d_4561_8f32_58398ec9aca31_splitWidths]            {               set endPos [expr $attrPos + $width - 1];               set bit [string range $source $attrPos $endPos];               set part [string trim $bit];               if { $keepEmptyParts || $part != \"\" } {                  FME_SetAttribute "$listName{$attrNum}" $part;                  incr attrNum;               };               incr attrPos $width;            };         };      }      else      {         proc $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_doSplit {}         {            global $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_c6d6701f_560d_4561_8f32_58398ec9aca31_splitDelim;            set delim [set $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_c6d6701f_560d_4561_8f32_58398ec9aca31_splitDelim];            set delimLength [string length $delim];            set source [FME_GetAttribute [FME_DecodeText {_attribute_names}]];            set keepEmptyParts [string equal {No} {No}];            set bits {};            set startIndex 0;            set nextIndex [string first $delim $source $startIndex];            while {$nextIndex >= 0} {              lappend bits [string range $source $startIndex [expr $nextIndex-1]];              set startIndex [expr $nextIndex + $delimLength];              set nextIndex [string first $delim $source $startIndex];            };            lappend bits [string range $source $startIndex end];            set listName [FME_DecodeText {_attribute_name_list}];            set attrNum 0;            foreach bit $bits            {               set trimmedPart [string trim $bit];               if { $keepEmptyParts || $trimmedPart != \"\" } {                  FME_SetAttribute "$listName{$attrNum}" $trimmedPart;                  incr attrNum;               };            }          }       }
FACTORY_DEF * TeeFactory    FACTORY_NAME $(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter    INPUT  FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_ParameterFetcher_OUTPUT"    OUTPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_OUTPUT"         @Tcl2($(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_doSplit)
# -------------------------------------------------------------------------
Tcl2 set ListSorterRenamedAttrPrefix ________
Tcl2 proc $(AttributeListEvaluator_WORKSPACE_NAME)_ListSorter_sort {} {    set COMMENT {    = NOTE: algorithm below does not support nested lists.    };    global ListSorterRenamedAttrPrefix;    regsub \"{}.*$\" {_attribute_name_list{}} \"\" listBaseNoBrace;    regsub \"{}.*$\" {_attribute_name_list{}} \"\{\" listBase;    regsub \"{}.*$\" {_attribute_name_list{}} \"\" listName;    set listBaseLen [string length $listBase];    set listNameLen [expr $listBaseLen - 1];    set listValueExtension [string replace {_attribute_name_list{}} 0 $listBaseLen {}];    set kMissingSidecarAttrSuffix {._________WAS_MISSING_________________};    set kCloseBrace \"\}\";    set kAnyOtherCharacters {*};    set COMMENT {    = To resolve PR 46315 (and friends), lets make a first pass to determine the full list of    = possible index numbers. Then we'll go through and make sure we have a KEY value for each    = of those.  We'll track what "keys" we added so that at the end we can REMOVE them so they stay MISSING.    };    set maxElementCount 0;    set attributeNames [FME_AttributeNames];    set listRegExp $listBaseNoBrace;    append listRegExp "\{(\[0-9\]+)\}";    set elementIndices {};    foreach attr $attributeNames {       if { [regexp $listRegExp $attr dummy subExpr] == 1 } {          lappend elementIndices $subExpr;          if { [expr $subExpr > $maxElementCount] } {             set maxElementCount $subExpr;          };       };    };    set curElement 0;    set COMMENT {    = Now that we have a list of the actual element numbers included in the list. Lets whip through and make sure    = we have an actual element for each of the "key" parts of the list we want to sort. If we don't, we'll    = make an element there with an empty value.  Note that we can't easily separate and sort NULL < missing < empty,    = but we'll live with that shortcoming in here as long as it is documented.    };    foreach curElement [lsort -integer -unique $elementIndices] {       set COMMENT {We found that there is at least some kind of element at this index in the list                    so we need to ensure there is a key element at this index};       set COMMENT {Minimum float is taken from std::numeric_limits<T>::lowest() cppreference web page.};       set indexKeyElementAttr $listBase$curElement$kCloseBrace$listValueExtension;       set indexKeyElementSidecarAttr $listBase$curElement$kCloseBrace$kMissingSidecarAttrSuffix;       if { ! [FME_AttributeExists $indexKeyElementAttr ] } {           set COMMENT {The key value attribute didn't exist. So lets put it on};           if { {} == {} } {              set COMMENT {doing string comparison so empty string};              FME_SetAttribute $indexKeyElementAttr {};           } else {              set COMMENT {doing numeric comparison so lowest float};              FME_SetAttribute $indexKeyElementAttr -3.40282e+38;           };           FME_SetAttribute $indexKeyElementSidecarAttr {FME_MISSING_VAL};       } elseif { {} != {} && [FME_IsAttributeNull $indexKeyElementAttr] } {           set COMMENT {attribute exists and we are doing numeric comparisons set null values to min float so they pass the lsort};           FME_SetAttribute $indexKeyElementSidecarAttr {FME_NULL_VALUE};           FME_SetAttribute $indexKeyElementAttr -3.40282e+38;       } elseif { {} != {} && [FME_GetAttribute $indexKeyElementAttr] == {} } {           set COMMENT {attribute exists and we are doing numeric comparisons set empty values to min float so they pass the lsort};           FME_SetAttribute $indexKeyElementSidecarAttr {};           FME_SetAttribute $indexKeyElementAttr -3.40282e+38;       };    };    set COMMENT {    =    For each attribute "listattr{<index>}.count" and all related attributes    =    "listattr{<index>}<extension>", create a list of the form    =       {$listattr{<index>}.count <index>}    =    and append the list to toSort, and keep a list of the extensions    =    for each index in the associative array listExtensions(<index>).    =    While iterating over the attributes, rename all such attributes to    =    "________listattr{<index>}<extension>" to    =    keep them out of the way, and to make them easier to clean up later.    =    Note that we're manually pulling out the index and extension, instead    =    of using regular expressions, as it is much more efficient    };    set toSort {};    foreach attr [FME_AttributeNames] {       set attrStart [string range $attr 0 $listNameLen];       if { $attrStart == $listBase } {          set braceEnd [string first \} $attr $listBaseLen];          set index [string range $attr $listBaseLen [expr $braceEnd - 1]];          set extension [string range $attr [expr $braceEnd + 1] end];          lappend listExtensions($index) $extension;          if { $extension == $listValueExtension } {             lappend toSort [list [FME_GetAttribute $attr] $index]          };          FME_RenameAttribute "$ListSorterRenamedAttrPrefix$attr" $attr;          set renamedAttrs($ListSorterRenamedAttrPrefix$attr) 1;       }    };    set COMMENT {    =    Sort the {$listattr{<index>} <index>} by index 0 (attr value)    };    set sortedList [lsort   -index 0 $toSort];    set destIndex 0;    set COMMENT {    =    For each list within sortedList, iterate over the list, renaming    =    "________listattr{<index>}<extension>" to    =    "listattr{<newIndex>}<extension>"    };    foreach pair $sortedList {       set elementNum [lindex $pair 1];       set newAttrBase "$listName\{$destIndex\}";       set oldAttrBase "$listName\{$elementNum\}";       foreach extension $listExtensions($elementNum) {          FME_RenameAttribute "$newAttrBase$extension" "$ListSorterRenamedAttrPrefix$oldAttrBase$extension";          unset renamedAttrs($ListSorterRenamedAttrPrefix$oldAttrBase$extension);       };       incr destIndex    };    set COMMENT {    =    If any attributes were renamed to their temporary names above, and they    =    did not contain the structure extension on which we were sorting, they    =    will still exist on the feature, and must be cleaned up.    };    set attrs [array names renamedAttrs];    if {[llength $attrs]} { eval FME_UnsetAttributes [array names renamedAttrs] };    set COMMENT {    =    = Lastly, go through and any of the MISSING, EMPTY, or NULL key values and set appropriately.  We'll have preserved their    = parallel list structure friends, but we need to restore the moved key to its original state: missing, blank or NULL    =    };    set curElement 0;    while { $curElement <= $maxElementCount } {        set indexKeyElementSidecarAttr $listBase$curElement$kCloseBrace$kMissingSidecarAttrSuffix;        if { [FME_AttributeExists $indexKeyElementSidecarAttr ] } {            set COMMENT {Get rid of the sidecar attribute and key attribute too};            set indexKeyElementAttr $listBase$curElement$kCloseBrace$listValueExtension;            set value [FME_GetAttribute $indexKeyElementSidecarAttr];            if {$value == {FME_NULL_VALUE}} {              FME_SetAttributeNull $indexKeyElementAttr;            } elseif { $value == {FME_MISSING_VAL} } {                FME_UnsetAttributes $indexKeyElementAttr;            } else {              FME_SetAttribute $indexKeyElementAttr {};            };            FME_UnsetAttributes $indexKeyElementSidecarAttr;        };        incr curElement;    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME $(AttributeListEvaluator_WORKSPACE_NAME)_ListSorter    INPUT  FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_AttributeSplitter_OUTPUT"    OUTPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_ListSorter_OUTPUT"         @Tcl2("$(AttributeListEvaluator_WORKSPACE_NAME)_ListSorter_sort")
# -------------------------------------------------------------------------
FME_PYTHON_PATH "$(FME_MF_DIR)"
FACTORY_DEF * PythonFactory    FACTORY_NAME $(AttributeListEvaluator_WORKSPACE_NAME)_PythonCaller    INPUT  FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_ListSorter_OUTPUT"    SYMBOL_NAME processFeature    PYTHON_NAMESPACE FMEOBJECTS    SOURCE_CODE import<space>fme<lf>import<space>fmeobjects<lf><lf>def<space>processFeature<openparen>feature<closeparen>:<lf><space><space><space><space>i<space>=<space>0<lf><space><space><space><space>for<space>attribute_name<space>in<space>feature.getAttribute<openparen><apos>_attribute_name_list<opencurly><closecurly><apos><closeparen>:<lf><space><space><space><space><space><space><space><space>feature.setAttribute<openparen><apos>_attribute_name_list<opencurly><apos><space>+<space>str<openparen>i<closeparen><space>+<space><apos><closecurly>.name<apos><comma><space>attribute_name<closeparen><lf><space><space><space><space><space><space><space><space>feature.setAttribute<openparen><apos>_attribute_name_list<opencurly><apos><space>+<space>str<openparen>i<closeparen><space>+<space><apos><closecurly>.value<apos><comma><space>feature.getAttribute<openparen>attribute_name<closeparen><closeparen><lf><space><space><space><space><space><space><space><space>feature.removeAttribute<openparen><apos>_attribute_name_list<opencurly><closecurly><apos><closeparen><lf><space><space><space><space><space><space><space><space>i<space>+=<space>1    OUTPUT PYOUTPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_PythonCaller_OUTPUT"
# -------------------------------------------------------------------------
# see logic in ListRenamerTransformerCfg::transformAllAttrs()
# this pretty much copies it but in TCL
Tcl2 proc $(AttributeListEvaluator_WORKSPACE_NAME)_ListRenamer_renamer {} {    set componentActions [split {_attribute_name_list<opencurly><closecurly>,$($(AttributeListEvaluator_WORKSPACE_NAME)_Evaluated_Attribute_List_Name)<opencurly><closecurly>} {,}];    set idx 0;    while {$idx < [llength $componentActions]}    {       lset componentActions $idx [FME_DecodeText [lindex $componentActions $idx]];       incr idx;    };    set selectedList [FME_DecodeText {_attribute_name_list<opencurly><closecurly>}];    set listActionLu [FME_DecodeText {__FME_RENAME__}];    if { [string length $selectedList] == 0 || [string length $listActionLu] == 0 } {       return;    };    foreach attr [FME_AttributeNames] {       regsub -all \"{\[0-9\]+}\" $attr \"{}\" flatAttr;       if {[string first $selectedList $flatAttr] != 0} { continue; };       set myParts [split $attr {.}];       set nameChanged false;       if { $listActionLu == {__FME_RENAME__} } {           set idx 0;           foreach {partName newName} $componentActions {              if {[llength $myParts] < $idx}  { break; };              regsub -all \"{\[0-9\]+}\" [lindex $myParts $idx] \"{}\" flatPart;              if {$flatPart != $partName} { break; };              if {[string first \"{}\" $partName] != -1} {                set baseName [string range $partName 0 [expr [string length $partName]-2]];                set baseNewName [string range $newName 0 [expr [string length $newName]-2]];                set newName [string map [list $baseName $baseNewName] [lindex $myParts $idx]];              };              lset myParts $idx $newName;              incr idx;              set nameChanged true;           };       } elseif  { $listActionLu == {__PROMOTE_SUBELEMENTS__} } {           set selectedParts [split $selectedList {.}];           if {[expr [llength $selectedParts]+1] == [llength $myParts]} {             set lastIdx [expr [llength $myParts]-1];             set lastPart [lindex $myParts $lastIdx];             set newPartNameBase $lastPart;             foreach {partName newName} $componentActions {                if {$partName == $lastPart} {                   set newPartNameBase [string range $newName 0 [expr [string length $newName]-3]];                   break;                }             };             set me [lindex $myParts [expr $lastIdx-1]];             set startBrace [string last \"\{\" $me];             set mynewIdx [string range $me $startBrace [string length $me]];             lset myParts $lastIdx {};             lset myParts [expr $lastIdx-1] $newPartNameBase$mynewIdx;             set nameChanged true;           };       } elseif { $listActionLu  == {__FME_PROMOTE__} } {           set nameChanged true;           set lastIdx [expr [llength $myParts]-1];           set lastPart [lindex $myParts $lastIdx];           lset myParts $lastIdx {};           set me [lindex $myParts [expr $lastIdx-1]];           set startBrace [string last \"\{\" $me];           set mynewIdx [string range $me $startBrace [string length $me]];           append lastPart $mynewIdx;           lset myParts [expr $lastIdx-1] $lastPart;           set partIdx 0;           while {$partIdx < [llength $myParts]}           {              if {[llength $componentActions] < [expr $partIdx*2]} { break; };              set flatPart [lindex $myParts $partIdx];              regsub -all \"{\[0-9\]+}\" [lindex $myParts $partIdx] \"{}\" flatPart;              set compName [lindex $componentActions [expr $partIdx*2]];              set newCompName [lindex $componentActions [expr $partIdx*2+1]];              if { $flatPart != $compName } { break; };              set compName [string range $compName 0 [expr [string length $compName]-2]];              set newCompName [string range $newCompName 0 [expr [string length $newCompName]-2]];              set newName [string map [list $compName $newCompName] [lindex $myParts $partIdx]];              lset myParts $partIdx $newName;              incr partIdx;           };       } else {           set nameChanged true;           set selectedParts [split $selectedList {.}];           if { $listActionLu != [lindex $myParts [expr [llength $selectedParts]-1]] } {             set idx 0;             while {[llength $myParts] > $idx } {               lset myParts $idx {};               incr idx;             };           } else {             set idx 0;             foreach {compName newCompName} $componentActions {                if { $idx >= [llength $myParts] } { break; };                set startBrace [string last \"\{\" $compName];                if { $startBrace != -1 } {                  set compName [string range $compName 0 [expr [string length $compName]-2]];                  set newCompName [string range $newCompName 0 [expr [string length $newCompName]-2]];                  set newName [string map [list $compName $newCompName] [lindex $myParts $idx]];                } else {                  set newName $newCompName;                };                lset myParts $idx $newName;                incr idx;             };             set replIdx [expr [llength $selectedParts]-1];             if { [llength $myParts] == [llength $selectedParts] } {                 set lastPart [lindex $myParts $replIdx];                 lset myParts $replIdx $lastPart;             }             else { lset myParts $replIdx {}; };          };       };       if {$nameChanged == true}       {         set myNewName {};         foreach part $myParts {            if {[string length $part] > 0} {                if {[string length $myNewName] > 0} {                  append myNewName "." $part;                } else {                  append myNewName $part;                };            };         };         set newNameLen [string length $myNewName];         if {$newNameLen > 0 && {NO} == {NO}} {           FME_RenameAttribute $myNewName $attr;         } elseif { $newNameLen > 0} {           FME_CopyAttribute $myNewName $attr;         }         elseif { $newNameLen == 0 && {NO} == {NO} } {              FME_UnsetAttributes $attr;         };       };    }; };
FACTORY_DEF * TeeFactory    FACTORY_NAME $(AttributeListEvaluator_WORKSPACE_NAME)_ListRenamer    INPUT  FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_PythonCaller_OUTPUT"    OUTPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_ListRenamer_OUTPUT"         @Tcl2("$(AttributeListEvaluator_WORKSPACE_NAME)_ListRenamer_renamer ")
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(AttributeListEvaluator_WORKSPACE_NAME)_Output1564091505 Output Collector"   INPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_ListRenamer_OUTPUT"   OUTPUT FEATURE_TYPE "$(AttributeListEvaluator_WORKSPACE_NAME)_Output"
INCLUDE [puts {MACRO WB_CURRENT_CONTEXT $(WB_OLD_CONTEXT_$(AttributeListEvaluator_WORKSPACE_NAME))}]
